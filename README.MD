# Spring Test Slices

Its importatnt to test only one thing. Isolate the logical layers above and below that thing under test. These are the invariants. In a Spring Boot application, autoconfiguration produces a large monolithic application context. 

Test slices allow us to segment the application context in terms of logical layers. As an example, the `WebMvcTest` slice only includes components related to the web tier, like `@Controller`-annotated components.

As an example, let's look at the structure of a unit test that looks something like the default unit test generated by the [Spring Initializr](http://start.spring.io). 

SliceTest.java: 

    @RunWith(SpringRunner.class)
    @SpringBootTest
    public class DefaultTest {

        @Autowired
        private SpinRepository spinRepository;

        @Test
        public void contextLoaded() {
            Assertions.assertThat(this.spinRepository).isNotNull();
        }
    }

This is a simple unit test that loads the entrie spring boot application contet. if your application has `spring-boot-starter-web` on the classpath, and you run such a test that interacts with your data acess layer, you'd still end up starting, setting up and then tearing down all the Spring mVC machinery and an embedded web server, like Apache Tmcat, just to be able to run this code. In essence, the application's configuration is monolithic.

Test slices, introduced in Spring Boot 1.4, let us segment parts of our application context, isolating the parts of the object graph - the layers - that we want to test from the layers we don't. 

Let's look at a simple test slice, to make the idea concrete. Here's a test that uses the `@DataJpaTest` slice.

DataJpaTest.java:

    @RunWith(SpringRunner.class)
    @DataJpaTest(showSql = true) // the test slice
    public class JpaSliceTest {

        @Autowired
        TestEntityManager testEntityManager;

        @Autowired
        SpinRepository spinRepository;

        @Test
        public void testShouldRecordNewSpin() {
            Spin entity = testEntityManager.persistFlushFind(new Spin(null, new Date(), Directions.UP));
            Assertions.assertThat(entity).as("is a persistent entity").isNotNull();
            Assertions.assertThat(entity.getDirection()).as("Spin has direction").isNotNull();
            Assertions.assertThat(entity.getTimestamp()).as("Spin was recorded for real").isNotNull();
        }
    }

This class tests that we;re able to persist a JPA entity, `Spin`, correctly. It uses `@DatajpaTest`, not `@SpringBootTest`, to setup an `ApplicationContext` geared for data access. Let's look at how `@DataJpaTest` looks.

InsideOfDataJpaAnnotation.java:

    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Inherited
    @BootstrapWith(SpringBootTestContextBootstrapper.class)
    @OverrideAutoConfiguration(enabled = false)
    @TypeExcludeFilters(DataJpaTypeExcludeFilter.class)
    @Transactional
    @AutoConfigureCache
    @AutoConfigureDataJpa
    @AutoConfigureTestDatabase
    @AutoConfigureTestEntityManager
    @ImportAutoConfiguration
    public @interface DataJpaTest {

        @PropertyMapping("spring.jpa.show-sql")
        boolean showSql() default true;

        boolean useDefaultFilters() default true; 

        Filter[] includeFilters() default {};

        Filter[] excludeFilters() default {};

        @AliasFor(annotation = ImportAutoConfiguration.class, attribute = "exclude")
        Class<?>[] excludeAutoConfiguration() default {};
    }

The annotation is itself meta-annotated with a number of other annotations. Lets start with the highlights: the `@OverrideAutoConfiguration(enabled = false)` disables the default Spring Boot autoconfiguration. Subsequent annotations then seletively re-instate certain auto configurations. `@AutoConfigureCache` and `@AutoConfigureDataJpa` reinstate Springs support for caching an Spring s support for Spring Data JPA. 

`@AutoConfigureTestDatabase` and `@AutoConfigureTestEntityManager` contribute new objects that don't (and shouldn't) need to exist in production code but that are useful to have in a testin gappliction context. The first annotration, `@AutocofugureTestDatabase` selectively replaces any `javax.sql.DataSource` beans in the `applicationContext` and replaces them with an in-memory test database. This way, even if you have configured an PostgreSQL DataSource in your applkication context, youre not making ive fire calls to a real dataase. Instead, you're be working with a lightweight, dispoable test `DataSource`. You don;t need to setup and teardown its state, it'll do that itself when the process dies! 

`@AutocnfigureTestEntityManager` configures an object, `TestEntityManager`, which provides convenient finder methods that make testing nteractions with the JPA `EntityManager` easier. 

The annotation also provides a `@PropertyMapping` that triggers the `spring.jpa.show-sql` property which in turn prints out the SQL statements being executed to the console. This is oarticularly useful when debugging and developing code, but not something you'd necessarily want in your production code. 

There are many other test slices in the Spring Boot ecosystem. Here, for example, is a test that uses the `@WebMvcTest`. 

    MvcSliceTest.java:

    @RunWith(SpringRunner.class)
    @WebMvcTest
    public class MvcSliceTest {
        @Autowired
        MockMvc mockMvc;

        @MockBean
        SpinRepository spinRepository;

        @Before
        public void setUp() {
            Mockito.when(spinRepository.findAll())
                    .thenReturn(Arrays.asList(
                            new Spin(null, new Date(), Directions.CHARM),
                            new Spin(null, new Date(), Directions.BOTTOM),
                            new Spin(null, new Date(), Directions.UP)
                    ));
        }

        @Test
        public void testShouldReturnSpins() throws Exception {
            mockMvc.perform(MockMvcRequestBuilders.get("/spins"))
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8_VALUE))
                    .andExpect(MockMvcResultMatchers.jsonPath("@.[0].direction").hasJsonPath())
                    .andExpect(MockMvcResultMatchers.jsonPath("@.length()").value(3));
        }
    }

The `@WebMvcTest` annotation keeps in the Spring application context only those components related to the web tier, like `@Controller` and `@RestController`-annotated components. Things like our `SpinREpository`, which is in the layer concerned with persistence, are not included. This is fine as we dont want to interact iwth that, anyway. 

In the web MVC test, we are trying to confirm that our web tier works as we expect. We will mock out the bean. Spring Boot includes the `@MOckBean` annotation which creates a Mockito-backed mock bean of whatever type the field on which the annotation is sat is. If theres a bvean of that tupe in the appliction context, then itll replace that bean. if there are no beans of that type, then it'll initialize the application context with an instance of that bean. 

In this exmple, we use mockito to create a srub that is preprogrammed to return certain results so that we can then use the Spring MVC test framework `MockMvc` mock client to test the controller.

# Next Steps

We've looked at test slices in this simple example. We have only looked at two test slices, but there are a good deal more included in spring Boot and you could create your own, as well. (Perhaps thats a topic for another blog post!)

