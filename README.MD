# Spring Test Slices

Simplify testing by isolating the logical layers above and below that thing under test. These are the invariants. In a Spring Boot application, autoconfiguration produces a large monolithic application context.

Test slices allow us to segment the application context in terms of logical layers. As an example, the [@WebMvcTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.html) slice only includes components related to the web tier, like `@Controller`-annotated components.

## The basic Test

As an example, let's look at the structure of a unit test that looks something like the default unit test generated by the [Spring Initializr](http://start.spring.io). 

SliceTest.java:

    @RunWith(SpringRunner.class)
    @SpringBootTest
    public class DefaultTest {

        @Autowired
        private SpinRepository spinRepository;

        @Test
        public void contextLoaded() {
            Assertions.assertThat(this.spinRepository).isNotNull();
        }
    }

This is a simple unit test that loads the entire spring boot application context. if your application has `spring-boot-starter-web` on the classpath, and you run such a test that interacts with your data acess layer, you'd still end up starting, setting up and then tearing down all the Spring MVC machinery and an embedded web server, like Apache Tomcat, just to be able to run this code. In essence, the application's configuration is monolithic.

## Testing just JPA

Test slices, introduced in Spring Boot 1.4, let us segment parts of our application context, isolating the parts of the object graph - the layers - that we want to test from the layers we don't.

Let's look at a simple test slice, to make the idea concrete. Here's a test that uses the [@DataJpaTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/orm/jpa/DataJpaTest.html) slice.

DataJpaTest.java:

    @RunWith(SpringRunner.class)
    @DataJpaTest(showSql = true) // the test slice
    public class JpaSliceTest {

        @Autowired
        TestEntityManager testEntityManager;

        @Autowired
        SpinRepository spinRepository;

        @Test
        public void testShouldRecordNewSpin() {
            Spin entity = testEntityManager.persistFlushFind(new Spin(null, new Date(), Directions.UP));
            Assertions.assertThat(entity).as("iIs a persistent entity").isNotNull();
            Assertions.assertThat(entity.getDirection()).as("Spin has direction").isNotNull();
            Assertions.assertThat(entity.getTimestamp()).as("Spin was recorded for real").isNotNull();
        }
    }

This class tests that we're able to persist a JPA entity, `Spin`, correctly. It uses `@DatajpaTest`, not [@SpringBootTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html), to setup an `ApplicationContext` geared for data access. Let's look at how `@DataJpaTest` looks.

InsideOfDataJpaAnnotation.java:

    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Inherited
    @BootstrapWith(SpringBootTestContextBootstrapper.class)
    @OverrideAutoConfiguration(enabled = false)
    @TypeExcludeFilters(DataJpaTypeExcludeFilter.class)
    @Transactional
    @AutoConfigureCache
    @AutoConfigureDataJpa
    @AutoConfigureTestDatabase
    @AutoConfigureTestEntityManager
    @ImportAutoConfiguration
    public @interface DataJpaTest {

        @PropertyMapping("spring.jpa.show-sql")
        boolean showSql() default true;

        boolean useDefaultFilters() default true; 

        Filter[] includeFilters() default {};

        Filter[] excludeFilters() default {};

        @AliasFor(annotation = ImportAutoConfiguration.class, attribute = "exclude")
        Class<?>[] excludeAutoConfiguration() default {};
    }

The annotation is itself meta-annotated with a number of other annotations. Lets start with the highlights: the [@OverrideAutoConfiguration(enabled = false)](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/OverrideAutoConfiguration.html) disables the default Spring Boot autoconfiguration. Subsequent annotations then seletively re-instate certain auto configurations. [@AutoConfigureCache](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/core/AutoConfigureCache.html) and [@AutoConfigureDataJpa](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/orm/jpa/AutoConfigureDataJpa.html) re-instate Springs support for caching an Spring s support for Spring Data JPA.

[@AutoConfigureTestDatabase](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/jdbc/AutoConfigureTestDatabase.html) and [@AutoConfigureTestEntityManager](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/orm/jpa/AutoConfigureTestEntityManager.html) contribute new objects that don't (and shouldn't) need to exist in production code but that are useful to have in a testing appliction context. The first annotration, `@AutocofugureTestDatabase` selectively replaces any `javax.sql.DataSource` beans in the `applicationContext` and replaces them with an in-memory test database. This way, even if you have configured an PostgreSQL DataSource in your application context, youre not making live fire calls to a real database. Instead, you'll be working with a lightweight, dispoable test [DataSource](https://docs.oracle.com/javase/7/docs/api/javax/sql/DataSource.html). You don't need to setup and teardown its state, it'll do that itself when the process dies.

`@AutoconfigureTestEntityManager` configures an object, [TestEntityManager](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.html), which provides convenient finder methods that make testing nteractions with the JPA [EntityManager](https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html) easier.

The annotation also provides a [@PropertyMapping](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/properties/PropertyMapping.html) that triggers the `spring.jpa.show-sql` property which in turn prints out the SQL statements being executed to the console. This is oarticularly useful when debugging and developing code,but not something you'd necessarily want in your production code.

## Testing Just WebMVC

There are many other test slices in the Spring Boot ecosystem. Here, for example, is a test that uses the [@WebMvcTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.html).

    MvcSliceTest.java:

    @RunWith(SpringRunner.class)
    @WebMvcTest
    public class MvcSliceTest {
        @Autowired
        MockMvc mockMvc;

        @MockBean
        SpinRepository spinRepository;

        @Before
        public void setUp() {
            Mockito.when(spinRepository.findAll())
                    .thenReturn(Arrays.asList(
                            new Spin(null, new Date(), Directions.CHARM),
                            new Spin(null, new Date(), Directions.BOTTOM),
                            new Spin(null, new Date(), Directions.UP)
                    ));
        }

        @Test
        public void testShouldReturnSpins() throws Exception {
            mockMvc.perform(MockMvcRequestBuilders.get("/spins"))
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8_VALUE))
                    .andExpect(MockMvcResultMatchers.jsonPath("@.[0].direction").hasJsonPath())
                    .andExpect(MockMvcResultMatchers.jsonPath("@.length()").value(3));
        }
    }

The `@WebMvcTest` annotation keeps in the Spring application context only those components related to the web tier, like `@Controller` and [@RestController](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html)-annotated components. Things like our `SpinRepository`, which is in the layer concerned with persistence, are not included. This is fine as we dont want to interact with that, anyway.

In the web MVC test, we are trying to confirm that our web tier works as we expect. We will mock out the bean. Spring Boot includes the [@MockBean](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/mock/mockito/MockBean.html) annotation which creates a Mockito-backed mock bean of whatever type the field on which the annotation is sat is. If theres a bvean of that tupe in the appliction context, then itll replace that bean. if there are no beans of that type, then it'll initialize the application context with an instance of that bean.

In this example, we use mockito to create a stub that is preprogrammed to return certain results so that we can then use the Spring MVC test framework [MockMvc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html) mock client to test the controller.

## Next Steps

We've looked at test slices in this simple example. We have only looked at two test slices, but there are a good deal more included in spring Boot and you could create your own, as well.

[This demo by Stephane Nicoll does a wonderful job of describing how to create custom test slices for your application](https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4).

